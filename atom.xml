<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Something Witty]]></title>
  <link href="http://ElPiloto.github.io/atom.xml" rel="self"/>
  <link href="http://ElPiloto.github.io/"/>
  <updated>2014-07-16T02:10:33-04:00</updated>
  <id>http://ElPiloto.github.io/</id>
  <author>
    <name><![CDATA[Luis R. Piloto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sleep EEG: Boosting Classification Results]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/07/15/sleep-eeg-boosting-classification-results/"/>
    <updated>2014-07-15T09:37:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/07/15/sleep-eeg-boosting-classification-results</id>
    <content type="html"><![CDATA[<h2 id="the-results-below-ensemble-classification-results-round-1-are-all-useless">The results below “Ensemble Classification Results, Round 1” are all useless</h2>

<p>I messed up the calculation of average pattern in wake classification (which is used in creating the mcduff importance map in the preprocessing below).</p>

<h3 id="ensemble-classification-results-round-6---cross-validation-subject-1">Ensemble Classification Results, Round 6 - Cross-validation subject 1</h3>

<p><img src="http://ElPiloto.github.io/images/research/ensemble_results_subj1_round6.jpg" width="700" height="350" /></p>

<h3 id="ensemble-classification-results-round-3">Ensemble Classification Results, Round 3</h3>

<p>I used the following values to produce the plot below:
10-fold cross validation, GentleBoost, 200 Learners, Wake Time = 152ms, Freq = 7 Hz, Importance Map for Face</p>

<p><img src="http://ElPiloto.github.io/images/research/ensemble_results_subj1thru8_round3.jpg" width="700" height="350" /></p>

<h3 id="ensemble-classification-results-round-1-incorrect">Ensemble Classification Results, Round 1 (INCORRECT)</h3>
<p><strong>these results are wrong - leaving here for historical purposes only</strong></p>

<p>Previously, I went through and tried various combinations of boosting algorithms (LogitBoost, GentleBoost, Adaboost.M1), number of learners, and number of folds for a single subject (subject 01) to try to determine what to run across all subjects to get the best tradeoff between accuracy and running time.  Below is a summary of those results.</p>

<p><img src="http://ElPiloto.github.io/images/research/subj1_ensemble_params_testing.png" width="700" height="300" /></p>

<p>Ultimately, I chose the following: <br />
  <strong>GentleBoost:</strong> just as good accuracy as other algorithms <em>and</em> better running time than AdaBoost.M1 or LogitBoost for some parametrizations   <br />
  <strong>50-fold cross-validation:</strong> it seemed to me like accuracy would increase with the number of folds   <br />
  <strong>400 Learners:</strong> I was skeptical of AdaBoostM1’s results with 700 learners, that begin to overfit, so I aimed for something slightly higher than what I had tried (300 learners) that wouldn’t go too far in terms of overfitting.</p>

<p>Below are the results for running <strong>GentleBoost</strong> using the aforementioned parameters, transforming the sleep data with a face minus scene McDuff importance map using wake data from time-bin = 230ms and freq = 11 Hz.   </p>

<p>This is below what we’d like to get and is lower than I would have expected for the first subject.  Possible reasons this could be the case:<br />
  - not enough data per fold<br />
  - I (accidentally )probed boosting results on subject 1 with different parameters than used for the current results: <br />
     - time bin = 152 ms<br />
     - freq = 7 Hz <br />
     - mcduff pattern = face   </p>

<p><img src="http://ElPiloto.github.io/images/research/ensemble_results_subj1thru8_round1.jpg" width="700" height="350" /></p>

<h3 id="next-steps">Next Steps</h3>

<p>The easiest problem to check for is to see if we get better results with more data in each fold, so I’ve launched a batch of results that use 20 folds.  This should give new results relatively quickly and we can move from there.  If that doesn’t ameliorate the poor accuracy, I’ll move to using the wake parameters used to probe subject 1 to make sure that the results for subject 1 are consistent with the results I got during the probing phase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Towers of Hanoi SFA and 8-ball SFA results: Robustness and Potential Neural Data to Model]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/07/06/towers-of-hanoi-sfa-and-8-ball-sfa-results-robustness-and-potential-neural-data-to-model/"/>
    <updated>2014-07-06T15:29:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/07/06/towers-of-hanoi-sfa-and-8-ball-sfa-results-robustness-and-potential-neural-data-to-model</id>
    <content type="html"><![CDATA[<h4 id="towers-of-hanoi-to-do">Towers of Hanoi To-Do:</h4>
<ol>
  <li><strong>Run SFA on random walk using multiple different random number seeds</strong> </li>
  <li>I am using the same starting location, this might affect the solutions found by SFA.  However, looking at the average input values (<code>SFA_STRUCTS.avg0</code>) shows that each feature has an average value of approximately 0.33, indicating that we do traverse all configurations equally frequently.</li>
  <li><code>sfa_tk</code> toolbox does not give features with unit variance when performing linear SFA. This might be a problem in the general case, but shouldn’t be a problem for towers of hanoi because the point of getting unit variance is so that the weights you find that minimize the derivative are directly comparable to each other.  But in our case, the derivatives should already be directly comparable because the input features all have exactly the same distribution for a random walk on towers of hanoi. I’m not entirely sure about this last bit, so I’ll have to verify this if Ari doesn’t have any useful input on the matter - easy way forward: look at MDP (python SFA implementation).</li>
</ol>

<h4 id="general-tips-for-sfatk-toolbox">General Tips for sfa_tk toolbox</h4>
<ol>
  <li><code>SFA_STRUCTS.SF</code> - contains slow feature functions along the rows</li>
  <li>Can get degenerate eigendecompositions, where an eigenvalue has greater algebraic multiplicity than geometric multiplicity (e.g. $ (2 - \lambda)^2(3-\lambda)^2 $ – alg. mult = 2, geometric = 1 for both eigenvalues).  In this case, extracted slow features are redundant (though they’ll have opposite signs).</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SFA Nonmarkov: Modify network, maze size and type, visualize gates]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/06/24/sfa-nonmarkov-modify-network/"/>
    <updated>2014-06-24T13:38:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/06/24/sfa-nonmarkov-modify-network</id>
    <content type="html"><![CDATA[<h3 id="overview-of-simulations">Overview of simulations</h3>
<ol>
  <li>Look at the gate values along the maze trajectories (previously we only looked at the hidden state values). Recall that a long-short term memory network has three gates: read, write, and forget   </li>
  <li>We also need to look at our old MDS plots of the hidden layers and label the trajectory (previously we only showed whether a representation belonged to the center hallway or right or left outer maze locations)</li>
  <li>We want to see if we get any qualitative differences as we change the width of the maze.  </li>
  <li>We want to see if changing the maze type to be a ring will still yield the segmenting behavior we see from SFA  </li>
  <li>We want to see if we get any qualitative differences as we change the number of hidden units</li>
</ol>

<h3 id="different-num-hidden-units">Different Num Hidden Units</h3>

<h4 id="hidden-unit-mds-plots">Hidden Unit MDS Plots</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_width3_hidden5_loop.png" width="750" height="350" /> 
<img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_width3_hidden3_loop.png" width="750" height="350" /> </p>

<h5 id="observations">Observations:</h5>
<ol>
  <li>Much cleaner separation of states with 5 hidden units compared to 3 hidden units based on the loop to which they belong.</li>
  <li>Also get cleaner separation of states based on center versus non-center.</li>
  <li><strong>These results suggest that the hidden layer representation generated using 5 hidden units might be a better representation for looking at the benefits of SFA.</strong></li>
</ol>

<h4 id="hidden-unit-similarity-plots-according-to-location-on-maze">Hidden Unit Similarity Plots According to Location on Maze</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/Linear_corr_states_hidden_representation_width3_hidden5.png" width="750" height="350" /> 
<strong>Figure 2a) 5 Hidden Units</strong>
<img src="http://ElPiloto.github.io/images/research/sfa_lstm/Linear_corr_states_hidden_representation_width3_hidden3.png" width="750" height="350" /> 
<strong>Figure 2b) 3 Hidden Units</strong>  </p>

<h5 id="observations-1">Observations:</h5>
<p>This is just another way of seeing how much cleaner the 5 hidden units representation is.</p>

<h4 id="linear-sfa-top-2-slowest-features">Linear SFA Top 2 Slowest Features</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/sfa_1st_2_features_rm_1st_visit_width3_hidden5.png" width="750" height="350" /> 
<strong>Figure 3a) 5 Hidden Units</strong>
<img src="http://ElPiloto.github.io/images/research/sfa_lstm/sfa_1st_2_features_rm_1st_visit_width3_hidden3.png" width="750" height="350" /> 
<strong>Figure 3b) 3 Hidden Units</strong>   </p>

<h5 id="observations-2">Observations:</h5>
<ol>
  <li>Here we see exactly what we hoped for in the 5 hidden units case: the first slow-feature indicates which loop we’re on!</li>
  <li>The question is: how much of this is the neural network and how much of this is SFA? Well let’s look at the plots below of the raw hidden layer values across the maze.  If the neural network is doing all the heavy lifting, then we would see a single, slowly varying feature that encodes the loops direction but this doesn’t seem to be the case!</li>
</ol>

<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_on_maze_raw_left_width3_hidden5.png" width="750" height="350" /> 
<strong>Figure 4a) 5 Hidden Units</strong>
<img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_on_maze_raw_right_width3_hidden5.png" width="750" height="350" /> 
<strong>Figure 4b) 5 Hidden Units</strong>   </p>

<p><strong>NOTE:</strong> These colors look exactly the same along the central corridor (which would be troubling), but their values are actually different if you look at the numbers.</p>

<h3 id="different-maze-size----width-7-5-hidden-units">Different Maze Size  - Width 7, 5 Hidden Units</h3>

<h4 id="hidden-unit-mds-plots-1">Hidden Unit MDS Plots</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_mds_width7_hidden5.png" width="750" height="350" /> </p>

<h4 id="linear-sfa-top-2-slowest-features-1">Linear SFA Top 2 Slowest Features</h4>

<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/sfa_linear_1st2features_width7_hidden5.png" width="750" height="350" /> </p>

<h3 id="different-maze-structure">Different Maze Structure</h3>

<h4 id="hidden-unit-mds-plots-2">Hidden Unit MDS Plots</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/hidden_layer_mds_width7_hidden5.png" width="750" height="350" /> </p>

<h4 id="linear-sfa-top-2-slowest-features-2">Linear SFA Top 2 Slowest Features</h4>
<p><img src="http://ElPiloto.github.io/images/research/sfa_lstm/sfa_1wayloop_width7_hidden5.png" width="750" height="350" /> </p>

<h3 id="meeting-with-mattbot">Meeting with Mattbot:</h3>

<h4 id="observations-3">Observations:</h4>
<ol>
  <li>It does seem like the first slow feature encodes which outer loop we’re on.   </li>
  <li>Cooler than that, our second slow feature for the width 7, 5 hidden units case, encodes which step of the outer loop we’re on, regardless of which direction the loop is.  This is motherfucking abstraction! We’re going to try to connect this to to-do item #4.</li>
</ol>

<h4 id="to-do">To-Do:</h4>
<ol>
  <li>Why are the slow-features on such a small scale?    </li>
  <li>Why are the hidden layer representations (think MDS width3, hidden5) so similar at the fork point - Matt thinks I might be off by one because the point just after the fork diverges which is what you would expect from the fork point - since they make vastly different predictions.  </li>
  <li>Will PCA give us anything useful?    </li>
  <li>I should read a paper on rat neurophysiology, an older paper - they showed that in an 8-arm radial maze, certain PFC cells encoded specific parts of an arm, without being specific to the particular arm.  This is similar to our second slow feature in the </li>
  <li>Check that these results are invariant o the number of hidden units and size of the maze.</li>
</ol>

<h4 id="other-to-do">Other to-do:</h4>
<p>This isn’t related to the non-markov, but to the factored state towers of hanoi: I was tasked with performing slow feature analysis on a random walk on a factored state representation of the towers of hanoi task.  It seems like I’m getting a result that Ari wasn’t able to: The first slow feature seems to represent the location of the largest ring.
* I should check with Ari to make sure I did things the way he did, too <br />
* I should show Matt the MDS of the slow features <br />
* I should make sure all of theslow features load on all dimensions of the original input space.<br />
* We’re not sure what the second slowest feature should look like, but it seems like it might be the configuration of the second largest ring conditioned on the location of the largest ring.  That’s definitely what the scatter plot of the first two features looks like.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG 8 Subjects]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/06/23/sleep-eeg-9-subjects/"/>
    <updated>2014-06-23T12:14:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/06/23/sleep-eeg-9-subjects</id>
    <content type="html"><![CDATA[<h2 id="all-the-interpretations">All the interpretations</h2>

<p>Hi Ken,  </p>

<p>Here’s the scoop.  We can definitely classify wake data (see Figure 1a below) The best time bin for the wake data isn’t consistent across all subjects, but it does seem to peak at 230ms, which is consistent with Ehren’s results ( compare figure 1b to figure 4: http://compmem.princeton.edu/publications/NewmanNorman10.pdf)  Our classification results aren’t as good as Ehren’s, he had a peak averaged AUC of 0.7, but I’m not too worried about it - what do you think?  There might be some utility to looking at classification for slightly later timebins (although Ehren’s results do peak at 200ms so we might already be looking at the best time bin)   </p>

<p><strong>Classifying sleep?</strong> 	</p>

<p>We tried three different sleep classification methods:<br />
1. Feature selection on all the frequencies within a particular time bin of sleep data.
2. Transform the sleep data using the average pattern of activity across all electrodes at a particular time-bin and frequency of the wake data.
3. Transform the sleep data using the importance map generated by the wake classification instead of the average pattern of activity - this should weight the different electrodes according to how informative they are for wake classification.</p>

<p>For method 1, we’re not getting any consistently classifiable timebins across subjects (figure 3a and 3b) which would have been the nicest result.  Additionally, having good wake AUC doesn’t mean that subject will have good sleep AUC.</p>

<p>The good news is that methods 2 and 3 show comparable classification AUC to method 1 and sometimes do even better.  Moreover, there isn’t a link between good classification for a time bin using method 1 compared to method 2 or 3 (e.g. method 1 classification for subject 2 doesn’t do so hot for timebins 152-230, but if you look at <a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_avg_pattern/sleep_transform_cv_auc_scene_subj2.png"> this plot</a> for method 2 classification for subject 2 - it’s pretty clear that that is a helpful time bin ).  These two observations give me confidence that the two sleep transform methods are genuinely helpful preprocessing steps.   </p>

<p>Moreover, I’ve been pretty excited about these sleep transform methods because they frequently, though not always, produce strong bands of good classification for particular timebins of the sleep data.</p>

<p>So a logical next question is to determine which method of the two sleep transform methods are better.  It seems like we get stronger bands appearing with method 2 compared to method 3 (you can check this out for yourself just quickly scrolling through the dump of the plots for both <a href="http://ElPiloto.github.io/blog/2014/07/01/sleep-eeg-transform-avg-pattern/">method 2</a> and <a href="http://ElPiloto.github.io/blog/2014/07/01/sleep-eeg-mcduff-transform/">method 3</a>).  There is some agreement between these bands across the two methods, but not always (example plots: <a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_avg_pattern/sleep_transform_cv_auc_pval_face&amp;scene_subj4.png"> method 2 </a> <a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_mcduff/sleep_MCDUFF_transform_subj_4_cv_acc_pval_face&amp;scene.png"> method 3</a>   </p>

<p>Another degree of freedom is which wake pattern do we use to transform the data: face or scene or face minus scene.  I expected there to be variability between the face and scene transformations, but was surprised to find that the face minus scene didn’t just look like the combination of the face and scene results.  Here’s an example of that:   </p>

<p><a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_avg_pattern/sleep_transform_cv_acc_pval_face_subj8.png">face</a>   </p>

<p><a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_avg_pattern/sleep_transform_cv_acc_pval_scene_subj8.png">scene</a>    </p>

<p><a href="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/sleep_xform_avg_pattern/sleep_transform_cv_acc_pval_face&amp;scene_subj8.png">face minus scene</a>   </p>

<p>This leads me to believe that in the future we should train a sleep classifier that gets both face and a scene transformed data.  The dot-product is sensitive to magnitude, so it could be that there is some useful information in the indivudal face and scene patterns that gets lost when we subtract the two.  What do you think?</p>

<p>The main thing I’ve taken away from this data is that there are timebins of the sleep data that are classifiable, but that they vary across subjects.  This implication of this being that we have to combine the results of multiple classifiers (tested on different timebins) when we try to connect the classification to subsequent memory - but that the particular classifiers we use will have to vary across subjects.  I think an important thing to figure out is how we want to select which classifiers to use for a subject.  I’ve gone through and written down a bunch of time bins that I think look good for each subject on the second page of our EEG to-do <a href="https://docs.google.com/spreadsheets/d/1TIOy-4DN4adDDVBKbuRZ2MuI5g-Hg7KWm1nBKjwSHsU/edit?usp=sharing">spreadsheet</a>, but that was done entirely by hand which doesn’t feel right.  </p>

<p>In general, I think we could proceed to linking the classifier to the behavioral or that we could try to improve the classification.  For the latter, I have a crazy idea bout using an “auto-encoder” for preprocessing the sleep data.  We could feed the network sleep data and have it’s target be the corresponding wake image.  We could apply this network in a leave-one-out fashion in order to preprocess sleep data for a regular classifier.  Seems like it’d be pretty tough to train the network given the dimensionality of the data and the relatively small number of training samples, but I figured it’s worth mentioning.  I’ll wait to hear what you think about all this, but I’m going to dedicate my brain cycles to the problem of figuring out how to select which time bins to use.</p>

<h3 id="wake-classification-results">Wake Classification Results</h3>
<p>These are important because it’s likely we’ll want to exclude subjects with poor wake cross-validation AUC from subsequent analyses.</p>

<p><img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/wake_AUC_most_subjects.png" width="700" height="350" /></p>

<p><strong>Figure 1a:</strong> This shows the AUC for leave-one-out cross-validation on wake EEG data training on all the z-scored frequencies corresponding to a particular time bin as indicated on the y-axis.  The AUC was calculating by training a classifier that distinguishes between all classes, but only testing on patterns that corresponded to either a celebrity or a landmark.  The AUC was calculated by feeding in the difference between the output for the celebrity one-vs-all classifier and the landmark one-vs-all classifier for each cross-validation fold and the plotted values show the mean AUC across all cross-validation folds.  We had previously looked at the cross-validation accuracy for the first two subjects across a wider range of times, but narrowed it down to these four windows.</p>

<p><code>plot_loopify_time_sweep_results_AUC.m </code>  <br />
<code>classify_piloy_log_reg_time_sweep_driver.m </code>      </p>

<p><img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/wake_auc_avgd.png" width="700" height="350" /></p>

<p><strong>Figure 1b:</strong> Average AUC per time bin</p>

<h3 id="sleep-cross-validation-classification-all-frequencies-per-time-bin">Sleep Cross-Validation Classification: All Frequencies Per Time Bin</h3>
<p><strong>NOTE:</strong> These results were supposed to be for performing feature selection, but I accidentally set the feature selection statistical threshold to 1, which is the same as not using feature selection.  <del>Re-running these results with feature selection.</del>  The results actually containing feature selection are just below.</p>

<p><img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/all_9subjects_sleep_CV_AUC_feature_select.png" width="700" height="350" />
<strong>Figure 2a)</strong> We plot the AUC for classification of celebrity vs. landmarks during sleep across all our subjects (y-axis).  This was calculated by performing cross-validation (somewhere between 15-fold and 40-fold depending on the number of sleep patterns available) using all frequencies z-scored across electrodes for a particular timebin (x-axis). <br />
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/all_9subjects_sleep_CV_AUC_feature_select_PVAL.png" width="700" height="350" />
<strong>Figure 2b)</strong> We plot the p-values for combinations of subjects and time bins with sleep cross-validation AUC values that are calculated via a shuffled permutation test whereby the labels of the classes are shuffled, we train a classifier with the shuffled patterns, and look at the cross-validation AUC for this shuffled dataset. Areas in red have p-values &gt; 0.05.
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/all_9subjects_sleep_CV_acc_feature_select.png" width="700" height="350" />
<strong>Figure 2c)</strong> Instead of calculating the AUC, we plot the classification accuracy - this should be pretty similar to Figure 2b.
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/all_9subjects_sleep_CV_acc_feature_select_PVAL.png" width="700" height="350" />
<strong>Figure 2d)</strong> Here we plot the p-values for the classification accuracies.</p>

<h3 id="sleep-cross-validation-classification-feature-selection-all-frequencies-per-time-bin">Sleep Cross-Validation Classification Feature Selection: All Frequencies Per Time Bin</h3>

<p><img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/9_subjects_CV_ACTUAL_AUC_feature_select.png" width="700" height="350" />
<strong>Figure 3a)</strong> We plot the AUC for classification of celebrity vs. landmarks during sleep across all our subjects (y-axis).  This was calculated by performing cross-validation (somewhere between 15-fold and 40-fold depending on the number of sleep patterns available) using all frequencies z-scored across electrodes for a particular timebin (x-axis). <br />
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/9_subjects_CV_ACTUAL_AUC_feature_select_PVAL.png" width="700" height="350" />
<strong>Figure 3b)</strong> We plot the p-values for combinations of subjects and time bins with sleep cross-validation AUC values that are calculated via a shuffled permutation test whereby the labels of the classes are shuffled, we train a classifier with the shuffled patterns, and look at the cross-validation AUC for this shuffled dataset. Areas in red have p-values &gt; 0.05.
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/9_subjects_CV_ACTUAL_acc_feature_select.png" width="700" height="350" />
<strong>Figure 3c)</strong> Instead of calculating the AUC, we plot the classification accuracy - this should be pretty similar to Figure 2b.
<img src="http://ElPiloto.github.io/images/research/sleep_eeg_9_subjects_06_23_2014/9_subjects_CV_ACTUAL_acc_feature_select_PVAL.png" width="700" height="350" />
<strong>Figure 3d)</strong> Here we plot the p-values for the classification accuracies.</p>

<h3 id="sleep-cross-validation-transform-sleep-pattern-by-average-wake-pattern">Sleep Cross-Validation: Transform Sleep Pattern By Average Wake Pattern</h3>
<p><a href="http://ElPiloto.github.io/blog/2014/07/01/sleep-eeg-transform-avg-pattern/"> dump of plots </a>   </p>

<p>We have 4 x 3 plots per subject (4 plots (AUC, accuracy, and p-val map for both of those) for each result, 3 different results: one for transforming the sleep data with the average face pattern, one for transforming with the average scene pattern, and one for transforming with the difference between the average face and average scene)</p>

<h3 id="sleep-cross-validation-transform-sleep-pattern-by-mcduff-importance-map">Sleep Cross-Validation: Transform Sleep Pattern By McDuff Importance Map</h3>
<p><a href="http://ElPiloto.github.io/blog/2014/07/01/sleep-eeg-mcduff-transform/"> dump of plots </a>   </p>

<p>We have 4 x 3 plots per subject (4 plots (AUC, accuracy, and p-val map for both of those) for each result, 3 different results: one for transforming the sleep data with the face mcduff importance map, one for transforming with the scene mcduff importance map, and one for transforming with the difference between the face and scene importance maps)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding SFA]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/06/11/understanding-sfa/"/>
    <updated>2014-06-11T11:14:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/06/11/understanding-sfa</id>
    <content type="html"><![CDATA[<h3 id="questions">Questions</h3>
<pre> Estimating Driving Forces of Nonstationary Time Series with Slow Feature Analysis, Wiskott (2003)</pre>
<p>What does it mean that slow-feature analysis only considers one point at a time?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Representational Similarity for Non-markov Task in LSTM Hidden Layers and SFA of Hidden Layers]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/06/10/representational-similarity-for-non-markov-task-in-lstm-hidden-layers-and-sfa-of-hidden-layers/"/>
    <updated>2014-06-10T15:48:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/06/10/representational-similarity-for-non-markov-task-in-lstm-hidden-layers-and-sfa-of-hidden-layers</id>
    <content type="html"><![CDATA[<p>We’re interested in how slow-feature analysis processes representations generated for a non-Markov task.  Towards this end, we apply slow-feature analysis to the hidden layer representation of a recurrent long short-term memory network that solves a non-Markovian task.  Importantly, we must first understand the hidden layer representation to see which components to the SFA’d hidden layer representation are generated from the slow-feature process and which were already present in the data.</p>

<h3 id="raw-hidden-layer-and-sfa-values">Raw Hidden Layer and SFA Values</h3>

<p>In a previous post, we have the raw hidden layer representation as we loop around the maze.  Here is an alternate version of that plot:
<img src="http://ElPiloto.github.io/images/research/hidden_layer_time_series.png" width="700" height="350" />
<strong>Figure 1:</strong> The first three subplots show the hidden layer activations for all three hidden nodes.  The last subplot shows the sum of all three activations.  The blue stripes in the background correspond to the times during which the “rat” is at the fork.  Alternating bands correspond to travelling in alternate directions of the maze.</p>

<p>This task is only non-Markovian in the center hallway: the correct action is entirely determined by the current location for all locations on the outside of the maze, but this is not true of the center hallway locations.  If we look at <code>hidden node 3</code>, we see that it only differs in value across loop directions at the timepoints near the fork.  Essentially, <code>hidden node 3</code> provides a linearly separable signal that indicates the direction of travel.  This is made even clearer in the two plots below showing the hidden layer activations for each location on the maze either on a leftward or rightward loop.</p>

<p><img src="http://ElPiloto.github.io/images/research/hidden_layer_on_maze_raw_left.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/hidden_layer_on_maze_raw_right.png" width="700" height="350" /></p>

<p><strong>Figure 2:</strong>  The normalized (-1 to 1) hidden layer representation, a vector of three values: one for each hidden node, for each location in the maze is plotted using <em>imagesc</em> at that location in the maze.  This is done for both leftward (top) and rightward (bottom) loops.  For example, the subplot in the middle row of the center column on the top plot (“Raw Hidden Layer Values - Left”) shows the hidden layer representation for that location in the maze during a leftward loop.  The hidden layer representation for that location during a rightward loop is shown on the bottom plot at the same location.  Do not be confused by the fact that the bottom plot for a rightward loop has filled in values for locations on the maze that are only visited during a leftward loop - these are just pasted in from the leftward loop for visualization purposes (and vice-versa for the leftward loop and rightward loop maze locations).</p>

<p>We see that <code>hidden node 3</code> has different values for the different loops along the center hallway, but nearly symmetric values along the outsides of the maze.  It is less clear what the other hidden units may be encoding.  A comparison of the first two hidden unit activations across loops shows that they code the outer loops of the maze differently, but not points along the center hallway (Figure 3 below).</p>

<p><img src="http://ElPiloto.github.io/images/research/hidden_nodes_1_and_2_comparison.png" width="700" height="350" />
<strong>Figure 3:</strong> Above we plot the activation for the first and second hidden units for each loop direction of the maze and subsequently their sum (bottom plot).  The x-axis labels analogous locations in the maze across the loops e.g. “Top Corner” on the middle plot shows the activation of <code>hidden node 2</code> for the top left corner location (blue) and the the top right corner (green).   Notably, the activations are pretty similar for the center hallway locations (“Fork”, “Bottom Center”, and “Mid Center”).</p>

<p>The network does find 20 unique states (the true number of unique states in our task) and we can see this just using the first two hidden unit activations.  This begs the question: is the third hidden unit needed?  It would be <strong>very</strong> helpful to plot the multidimensional scaling for all three hidden unit activations, <del>so maybe somebody (<em>cough</em> Luis <em>cough</em> <em>cough</em> a.k.a. my own self <em>cough</em>) should do that</del> here is that <a href="http://ElPiloto.github.io/images/research/hidden_layer_mds.png">plot</a>. Another diagnostic to assess the utility of this third hidden unit would be to look at how the slow-feature analysis output varies based on whether we give all three hidden units or just the first two.
<img src="http://ElPiloto.github.io/images/research/hidden_layer_representation_mds_rm_1st_visit.png" width="700" height="350" /> 
<strong>Figure 4:</strong> Above we plot the hidden unit activations for each time step in our trajectory of 20 loops around the maze.  Importantly, locations on the outside of the maze (circles with black or magenta outlines) cluster together across visits. The center locations, however, are cluster according to loop direction.</p>

<p>We can also look at the hidden layer represtation similarity from one location to the other locations as shown below.
<img src="http://ElPiloto.github.io/images/research/hidden_layer_self_similarity.png" width="700" height="350" /> 
<strong>Figure 5:</strong> This shows the representational similarity for each unique state (recall that not all locations correspond to unique states).  The labels along the axes correspond to different locations on the maze (also indicating the loop direction when relevant) using the key below.</p>
<center>
<img src="http://ElPiloto.github.io/images/research/legend_correlation_plots.png" width="450" height="65" /> 
</center>

<p>Below we show an alternative method for visualizing the hidden layer representation of a location to other locations.
<img src="http://ElPiloto.github.io/images/research/Linear_corr_states_hidden_and_sfa_hidden_representation.png" width="700" height="350" />
<strong>Figure 6:</strong> For each location in the maze, we create a subplot that shows the hidden layer representation for that location in the maze against all other locations in the maze.  For example, to look at the representational similarity between the top-left corner and the bottom-right corner, look at the top-left subplot and the bottom-right square within that subplot.  The similarity between a location and itself is also plotted, which is uninformative in the case of locations on the outside of the maze.  However, for locations that have multiple states (i.e. the fork location corresponds to both states “Fork - Leftward loop” and “Fork - Rightward loop”), the similarity is plotted across loop directions e.g. the top-center subplot shows the representational similarity for the fork location and the top-center value in that subplot corresponds to the representational similarity between the fork on a leftward loop and the fork on a rightward loop.</p>

<h3 id="dump-of-sfa-similarity-plots">Dump of SFA Similarity Plots</h3>
<p><img src="http://ElPiloto.github.io/images/research/Linear_corr_states_hidden_and_sfa_sfa3.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/Linear_corr_states_hidden_and_sfa_sfa2.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/Nonlinear_corr_states_hidden_and_sfa_sfa3.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/Nonlinear_corr_states_hidden_and_sfa_sfa2.png" width="700" height="350" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Ken Meeting]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/06/02/sleep-eeg-ken-meeting/"/>
    <updated>2014-06-02T11:27:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/06/02/sleep-eeg-ken-meeting</id>
    <content type="html"><![CDATA[<h3 id="context">Context</h3>

<p>After ending the first-year rotation, I’m now back on the hook for working on this sleep EEG project full-time.  This meeting was simply to re-orient ourselves and plan the next immediate steps.</p>

<h3 id="next-steps">Next Steps</h3>
<ol>
  <li>Area under ROC instead of classification accuracy   </li>
  <li>Represent goodness in terms of where it falls on the empirical null distribution (as opposed to previously where we were showing raw-classification accuracy which we really have no clue how good that should be)  </li>
  <li>Train sleep classifier using wake WEIGHTS instead of wake average pattern as template.  The rationale behind this is that the average pattern templates treat all electrodes as equally important, but this just isn’t true.  The importance maps will take that into account   </li>
  <li>Create existing plots for new subjects [n = 8] (!)</li>
</ol>

<h3 id="next-next-steps">Next Next Steps</h3>
<ol>
  <li>We need to think about how we can collapse down each sleep trial (playing of a sleep sound) into a single reactivation metric.  Currently, we have classifier output for different timebins of the sleep trial and it seems like the maximally-classifiable time bin varies across subjects. <br />
    <ul>
      <li>Train an “uberclassifier” that classifies across all timebins - this would give us a single reactivation score per trial   </li>
      <li>Is there a smart way of reducing the number of features we have?<br />
        <ul>
          <li>we might have some <em>a priori</em> ideas about which features to include.  </li>
          <li>we might want to look at the cross-validation accuracy along certain time-bins to narrow things down.   </li>
        </ul>
      </li>
      <li>This is where I thought a recurrent neural network might be helpful for us.  </li>
      <li>Alternative idea: train a higher-level classifier on the outputs of the individual time bin classifiers    </li>
    </ul>
  </li>
  <li>How do we relate reactivations to subsequent memory?  Recall that there will be multiple classifier readouts per item, perhaps something a la [P-CIT] (https://code.google.com/p/p-cit-toolbox/) would work for us.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paper: Deep Learning from Temporal Coherence in Video]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/05/30/paper-deep-learning-from-temporal-coherence-in-video/"/>
    <updated>2014-05-30T15:32:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/05/30/paper-deep-learning-from-temporal-coherence-in-video</id>
    <content type="html"><![CDATA[<h3 id="punchline">Punchline:</h3>

<p>They used a convolutional neural network to do object recognition on video streams.  Motivated by the idea that consecutive video frames likely contain the same objects and therefore should have similar representations, they modify the neural network cost function to include a “coherence” term:  </p>

<script type="math/tex; mode=display">% &lt;![CDATA[
 L_{coh}(\theta, inputx, inputy) = \begin{cases}
		  \|z_{\theta}(input_x) - z_{\theta}(input_y) \|_1  & \textbf{if x,y consecutive}\\
		  max(0, \delta - \|z_{\theta}(input_x) - z_{\theta}(input_y) \|_1)   & \textbf{otherwise}\\
\hline
\end{cases}  \\
\delta: \text{hyperparam push apart non-consecutive representations} \\
z_{\theta}(x) = \text{hidden layer representation for input x just before output layer}  %]]&gt;</script>

<h3 id="noteworthy-details">Noteworthy Details:</h3>
<p>Training: They do some weird training where you have to look at the output of the network for two different outputs, they call this a siamese architecture.</p>

<h3 id="ideas">Ideas:</h3>
<ul>
  <li>Modify $ L_{coh} $ to be a function of the number of time steps between inputs  </li>
  <li>What if we could use slow-features as a better proxy for temporal distance between training samples i.e. push representations closer together based on the difference between their slowest features?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LSTM trained multiple loops]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/05/22/lstm-trained-multiple-loops/"/>
    <updated>2014-05-22T15:46:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/05/22/lstm-trained-multiple-loops</id>
    <content type="html"><![CDATA[<h3 id="status">Status:</h3>

<ul>
  <li>Rudimentary system for importing rnnlib log information to matlab for performing SFA</li>
  <li><strong>Successfully trained LSTM on 20 loops through an eightball maze (same dimensions as last time): 0% misclassification</strong></li>
</ul>

<p><img src="http://ElPiloto.github.io/images/research/hidden_state_activations_width3_loops20.png" width="700" height="350" /></p>

<h3 id="questions-for-meeting">Questions for meeting</h3>
<ul>
  <li>What should we perform the SFA on?</li>
  <li>How many loops around the maze do we need?</li>
</ul>

<h3 id="next-steps">Next steps</h3>
<p>Look at similarity metric for each timestep using correlation matrix - send to Matt
Be wary of SFA on multidimensional data and throwing away certain features
Send SFA
Waldo task: Ari did SFA on the task (using sparse representation, 8 units
perhaps LSTM’ing Waldo task
generate figures for a week from now</p>

<p>short term memory for serial order - matt bot paper, network needs to remember things that aren’t relevant to current output, 
single unit recording analysis paper by bill newsome, analyzed by valerio monte, nature 2013 “context-dependent computations by recurrent dynamics in prefrontal cortex”</p>

<p>LSTM seems different than orthogonal</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LSTM Trained on Non-Markov Loop]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/05/22/lstm-trained/"/>
    <updated>2014-05-22T13:42:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/05/22/lstm-trained</id>
    <content type="html"><![CDATA[<h3 id="status">Status:</h3>

<p>Successfully trained (finally) a LSTM network on a single loop through an eightball maze.
The eightball maze had a width $= 7$, height $= 3$, giving a total of 17 locations in the maze.</p>

<p><img src="http://ElPiloto.github.io/images/research/non_markov_maze.png" width="700" height="350" /></p>

<p><strong>This is the architecture used:</strong> <br />
- input layer: represent each location as an input node<br />
- hidden layer: 2 LSTM blocks<br />
- output layer: represent each output location as an output node  </p>

<p><strong>Training/Testing:</strong> <br />
Input was a single sequence which consisted of a full loop around the maze, which takes 21 time steps. Testing was done simply by specifying the next step in the sequence.</p>

<p><strong>RNNLIB Config File &amp;&amp; CDL</strong></p>

<h3 id="next-steps">Next Steps:</h3>
<ul>
  <li>Run SFA on this output</li>
  <li>Train/test on sequences that have more loops around the maze  </li>
  <li>Run SFA on this output</li>
  <li>Logistical<br />
    <ul>
      <li>Develop method of transferring from rnnlib log files to matlab so that we can do SFA</li>
    </ul>
  </li>
</ul>

<h3 id="rnnlib-discoveries--questions">RNNLIB Discoveries &amp; Questions</h3>
<ul>
  <li>Default behavior is to have hidden layers be recurrent in time both forwards and backwards, this is <strong>NOT</strong> what we want for our current usage.  </li>
  <li><code>hiddenSize</code> controls the number of units in the hidden layer, to specify multiple hidden layers can add values here  </li>
  <li><code>hiddenBlock</code> still unclear what this does   </li>
  <li><code>inputBlock</code> not sure what the benefit of creating an input block is, it seems to just replicate the input layer and has the same exact activations when I look at the log file  </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Update 2]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/05/04/sleep-eeg-update-2/"/>
    <updated>2014-05-04T20:53:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/05/04/sleep-eeg-update-2</id>
    <content type="html"><![CDATA[<p>Here are some questions/conclusions regarding the new data:</p>

<h3 id="are-the-trained-classifier-weights-highest-at-the-frequencies-used-to-generate-the-wake-template--for-instance-given-that-sleep-data-was-transformed-using-the-faces-template-at-230-ms-and-10-hz-does-the-trained-sleep-classifier-have-high-weights-at-10-hz">Are the trained classifier weights highest at the frequencies used to generate the wake template?  For instance, given that sleep data was transformed using the faces template at 230 ms and 10 Hz, does the trained sleep classifier have high weights at 10 Hz?</h3>
<p>This does not seem to be the case.  If we look at the averaged (across time bins) classifier weights at each frequency, we see that there are hot spots of increased feature importance at frequencies that do not depend on the parameters used for the wake template generation.  This is illustrated in the figure below: we see increased feature importance at 3 Hz regardless of the  wake time bin and frequency used for generating the wake template.  We might be tempted to say there is a relationship between the encoding frequency and the feature importance at 10 Hz, but I don’t buy it given that we only see increased feature importance along the y-axis (indicating that there seems to be something informative about the sleep data at 10 Hz) but not the x-axis.</p>

<p><img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_faceMINUSscene_wake_template_subj1.png" width="700" height="350" /></p>

<h3 id="are-there-any-trends-in-increased-weights-across-any-of-the-following-parameters">Are there any trends in increased weights across any of the following parameters?</h3>

<h4 id="frequencies">Frequencies?</h4>
<p>Across both subjects, we see increased feature importance around 3 Hz.  Additionally, we can see, in both subjects, something around the 10 Hz range (10 Hz for subject 1,  7-12 Hz for subject 2) and a faint </p>

<h4 id="time-bins">Time bins?</h4>

<h4 id="face-vs-scene-vs-face-minus-scene">Face vs. Scene Vs. Face minus Scene</h4>

<h4 id="is-there-a-link-between-the-magnitude-of-the-trained-sleep-classifier-weights-and-the-maximum-cv-accuracy-achieved-at-that-particular-time-bin--this-will-indicate-whether-or-not-there-is-a-benefit-to-reducing-the-classification-process-even-further-using-a-subset-of-the-features">Is there a link between the magnitude of the trained sleep classifier weights and the maximum CV accuracy achieved at that particular time bin?  This will indicate whether or not there is a benefit to reducing the classification process even further using a subset of the features.</h4>

<p>Future To-do: Is there a link between the trained sleep classifier weights and the average cross-validation accuracy for the shuffled sleep?  What would this tell us about the underlying space?</p>

<h4 id="what-is-the-relationship-between-the-weights-for-the-sleep-transformed-classifier-compared-to-the-feature-selected-weights">What is the relationship between the weights for the sleep transformed classifier compared to the feature selected weights?</h4>
<p>I don’t have this data yet.</p>

<h4 id="shuffling-results-given-that-we">Shuffling results: given that we</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Update]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/05/04/sleep-eeg-update/"/>
    <updated>2014-05-04T18:45:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/05/04/sleep-eeg-update</id>
    <content type="html"><![CDATA[<h3 id="results">Results</h3>

<h4 id="shuffled-cross-validation-accuracy-using-transformed-sleep-data-item--5-on-to-do-list">Shuffled Cross-validation Accuracy Using Transformed Sleep Data (Item # 5 on To-Do List)</h4>
<p>The plots below were using the generate-template-on-wake-then-transform-sleep-data-then-train-a-sleep-classifier approach.  The x-axis corresponds to training on different sleep time bins (although we use all the frequencies) and the y-axis corresponds to using different time-freq pairs to generate the wake template.  The key part of this plot is that we <strong>randomly permuted the sleep labels</strong> - so we would hope to see 50% classification accuracy here (which unfortunately doesn’t seem to be the case).  Ideally, I would have multiple iterations of this shuffling, but so far I’ve only run a single shuffle - <strong>how serious is it that I haven’t run multiple iterations?</strong></p>

<p><img src="http://ElPiloto.github.io/images/research/subject_1sleep_transform_CV_shuffled.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_2sleep_transform_CV_shuffled.png" width="700" height="350" /></p>

<h4 id="sleep-cross-validation-accuracy-using-different-sleep-transformations-item-2-on-to-do-list">Sleep Cross-validation Accuracy using different sleep transformations (Item #2 on To-Do List)</h4>
<p>Previously, we had only tried the generate-template-on-wake-then-transform-sleep-data-then-train-a-sleep-classifier using the FACE template, the results below show cross-validation accuracy using the face template (same results as presented previously), the scene template, and face-minus-scene.</p>

<p><img src="http://ElPiloto.github.io/images/research/subject_1sleep_transform_CV.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_2sleep_transform_CV.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_3sleep_transform_CV.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_4sleep_transform_CV.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_5sleep_transform_CV.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/subject_6sleep_transform_CV.png" width="700" height="350" /></p>

<h4 id="sleep-cross-validation-accuracy-using-all-frequencies-feature-select-item-4-on-to-do-list">Sleep Cross-validation Accuracy Using All Frequencies Feature Select (Item #4 on To-Do List)</h4>
<p>This is pretty straightforward cross-validation accuracy performed on the labelled sleep data.  For each time bin of the sleep data, we z-scored the power spectrum at all frequencies across electrodes and trained a classifier using 10-fold cross-validation using standard p-value based feature selection.</p>

<p><img src="http://ElPiloto.github.io/images/research/all_2_subjects_sleep_CV_feature_select.png" width="700" height="350" /></p>

<h4 id="classifier-weights-for-sleep-transformed-data-item-1-on-to-do-list">Classifier Weights for sleep transformed data (Item #1 on To-Do List)</h4>
<p>Recall that we have a classifier for each combination of wake time-freq pair and sleep time.  Each classifier sweeps the template across each frequency of the time bin, yielding a classifier with as many features as there are frequencies.  Thus, visualizing the weights would require displaying the magnitude of the weight across three dimensions: wake time-freq pair, sleep time bin, and sleep frequency.  Instead of trying to plot some whacky surface, I’ve created plots that average the magnitude of the weights either across the sleep time bins OR across sleep frequencies - if a particular time bin or frequency looks promising from these plots, we can look at the uncollapsed results as needed.</p>

<p>The value displayed below is taken as follows:<br />
<code>
for each wake time-freq bin x sleep time bin pair:<br />
 &nbsp; &nbsp; &nbsp; &nbsp;for each cross-validation iteration:<br />
		 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;z-score weights<br />
	&nbsp; &nbsp; &nbsp; &nbsp;Avg weights over cross-validation iterations and take absolute value<br />
</code></p>

<p>This 3d matrix was then collapsed either across sleep time bins or sleep frequencies.  This was done for the various wake templates.  </p>

<p><strong>KEN:</strong> I know this is pretty different than the McDuff method for interpreting feature weights - but the requirement to average over the patterns made things difficult so I did things this way as a much easier to accomplish first pass.  It’s worth noting that the EEG analysis code rescales all features to be within the range of 0 and 1, so I think this crude way of looking at the features should still be pretty informative.</p>

<h4 id="face-minus-scene-wake-template">Face Minus Scene Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_faceMINUSscene_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_faceMINUSscene_wake_template_subj2.png" width="700" height="350" /></p>

<h4 id="face-wake-template">Face Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_face_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_face_wake_template_subj2.png" width="700" height="350" /></p>

<h4 id="scene-wake-template">Scene Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_scene_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collaped_weights_by_freq_scene_wake_template_subj2.png" width="700" height="350" /></p>

<h4 id="face-minus-scene-wake-template-1">Face Minus Scene Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_faceMINUSscene_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_faceMINUSscene_wake_template_subj2.png" width="700" height="350" /></p>

<h4 id="face-wake-template-1">Face Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_face_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_face_wake_template_subj2.png" width="700" height="350" /></p>

<h4 id="scene-wake-template-1">Scene Wake Template</h4>
<p><img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_scene_wake_template_subj1.png" width="700" height="350" />
<img src="http://ElPiloto.github.io/images/research/collapsed_weights_by_sleep_time_scene_wake_template_subj2.png" width="700" height="350" />
<!--### Questions-->
<!--##### Classifier Weights-->
<!--#. When we look at the magnitude of the trained classifier weights for various wake-template-frequencies, do we see that the weights are generally bigger at the frequencies that --></p>

<!--#### -->
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Update]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/04/20/sleep-eeg-update/"/>
    <updated>2014-04-20T14:41:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/04/20/sleep-eeg-update</id>
    <content type="html"><![CDATA[<h3 id="classification-results">Classification results</h3>
<p>Last time I showed a plot for CV accuracy of wake data generated by looking at individual time bins, but using all possible frequencies.  This plot is the logical next step: it considers individual frequencies - which I did for only the most promising time bins (again independently).  I didn’t use various regularization penalties this time ($\lambda = 1$ for current plot).  Additionally, this data was z-scored across electrodes for each frequency.  </p>

<p><img src="http://ElPiloto.github.io/images/research/sweep_time_freq.png" width="700" height="350" /></p>

<p>It’s harder to pick out the “best” frequencies from this plot (compared to picking the “best” times previously).  The ~alpha band seems to pop out for both subjects, but it might be worthwhile to investigate some of the gamma stuff going on in subject 2.   Also, note that the colorbars are on different scales for both subjects.  Also we can actually get higher classification accuracy for both subjects than we did using all frequencies like last time.</p>

<p>The next analysis step we discussed was to pick a vector consisting of the power across electrodes at a best time and frequency and use this to transform the sleep data and perform cross-validation on the sleep data using this transformed dataset. With the idea being that after we get good sleep cv-accuracy, we could look at the relationship between classifier output and memory.</p>

<p>Sleep Transformation refresher:
- for each time bin of the sleep data, compute dot-product between the z-scored power across electrodes at a given frequency and the “best vector” described above and do this for each frequency</p>

<h3 id="next-steps">Next steps</h3>
<p>I see two approaches:<br />
1. glob across subjects and generate transformed-sleep CV results across a range of times and frequencies that seemed promising for both subjects (150ms - 230ms, 7-13Hz)<br />
2. treat subjects independently, rank (time x freq) pairs by highest CV accuracy and generate transformed-sleep CV results for top 10 (time x freq) pairs   </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Update]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/04/16/sleep-eeg-update/"/>
    <updated>2014-04-16T12:50:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/04/16/sleep-eeg-update</id>
    <content type="html"><![CDATA[<h3 id="classification-results">Classification results:</h3>

<p>So far I’ve swept through the various time bins for two subjects and ran cross-validation on the wake data.  This was performed using leave one out cross-validation, zscoring the data across electrodes.   Additionally, I trained the classifier on all five categories (Faces, places, objects, scrambled faces, scrambled places), but only used the examples corresponding to faces or places for cross validation accuracy.  </p>

<p>Git branch: <code>sweep_features</code>
Git commit id#: <code>59c7561e0</code></p>

<p>Below is a plot of the results I got, although the <strong>columns are incorrect:</strong> <br />
- Column 1: Subject 1, Lambda = 1<br />
- Column 2: Subject 2, Lambda = 1<br />
- Column 3: Subject 1, Lambda = 50<br />
- Column 4: Subject 2, Lambda = 50<br />
- Column 5: Subject 1, Lambda = 100<br />
- Column 6: Subject 2, Lambda = 100  </p>

<p><img src="http://ElPiloto.github.io/images/research/sweep_time_bins.png" width="650" height="550" /></p>

<h3 id="next-steps">Next Steps:</h3>

<ul>
  <li>Look at next steps from previous meeting, they haven’t changed.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Non-markov SFA: Matt Botvinick Meeting]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/04/10/non-markov-sfa-matt-botvinick-meeting/"/>
    <updated>2014-04-10T17:54:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/04/10/non-markov-sfa-matt-botvinick-meeting</id>
    <content type="html"><![CDATA[<h3 id="status">Status:</h3>

<ul>
  <li>Still unable to train successfully on non-markov loop</li>
  <li>Tried the following things:
    <ol>
      <li>Training on markov loop (simply go around in a circle) and succeeded in training that network - this serves as a sanity check</li>
      <li>Tried lower learning rate</li>
      <li>Tried penalizing the training examples corresponding to the appropriate left or right choice more than other examples, but this produced funky, erratically erroneous behavior</li>
      <li>Switched state representation from $(x,y)$ coordinates to place cell locations:
        <ul>
          <li>Helped with training non-markov: now the network simply chooses one side and incurs the cost of being wrong once every 2 cycles</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="comments">Comments:</h3>

<ul>
  <li>Matt thought this is more like the problem you’d expect if the recurrent neural network was just having a hard time remembering</li>
</ul>

<h3 id="next-steps">Next Steps:</h3>

<ul>
  <li>Troubleshoot neural network:
    <ul>
      <li>Try using LSTM network (Schmidhuber probably has an implementation)
        <ul>
          <li><strong>Ensure</strong> that the LSTM network produces an internal, vector of scalar representation that we can subsequently use for SFA</li>
          <li>Matt would like a briefing of how LSTM works (though he didn’t explicitly ask for one, it’d be a sweet thing to do for him)</li>
        </ul>
      </li>
      <li>Alternatively: try, Larry Abbott and David Sussillo FORCE algorithm</li>
      <li>Alternatively: implement Matt’s recurrent neural network with an additional set of targets that serve as an autoencoder of the recurrent layer</li>
    </ul>
  </li>
</ul>

<h3 id="random">Random:</h3>
<ol>
  <li>Matt spoke about another motivation for using SFA, which was Earl Miller’s dog/cat discrimination task in monkeys with stimuli which were morphed on a continuum between dog and cat (I think).  That experiment showed that visual areas represented dogs and cats “veridically”, but that prefrontal areas represented the stimuli based on the category boundary (which was manipulated).  He thought, how would you come up with that representation?  Well, you would have to think that the time series is: stimulus, press left, receive reward and that maybe we could perform SFA on this.</li>
  <li>Matt mentioned there is a “teacher” in the Sussillo FORCE algorithm that prevents the network from being wrong on a particular trial - he thinks perhaps this relationship could be instantiated by the model-free and model-based systems.  Furthermore, that this teacher might only provide information some of the times - that it computes when it needs to monitor/control/teach/supervise the model-free system.</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Non-markov SFA]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/04/03/non-markov-sfa/"/>
    <updated>2014-04-03T17:31:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/04/03/non-markov-sfa</id>
    <content type="html"><![CDATA[<h2 id="meeting-with-matt-botvinick">Meeting with Matt Botvinick:</h2>

<h3 id="status">Status</h3>

<ul>
  <li>Got SFA toolbox installed on local machine   </li>
  <li>Generated figure eight trajectory  </li>
  <li>Trained elman neural network on figure eight trajectory (3x3 world) with <strong>unsatisfactory results:</strong>  </li>
</ul>

<h3 id="next-steps">Next Steps</h3>

<ul>
  <li>Troubleshoot neural network:<br />
    <ul>
      <li>Test on markov loop    </li>
      <li>Decrease learning rate (perhaps it’s getting stuck in a local minimum)   </li>
      <li>Use place cells instead of $(x,y)$ coordinates   </li>
    </ul>
  </li>
</ul>

<h4 id="read-paper-that-ari-sent-out">Read paper that Ari sent out:</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVPA evidence for offline reply predicts revaluation of action values]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/03/27/mvpa-evidence-for-offline-reply-predicts-revaluation-of-action-values/"/>
    <updated>2014-03-27T12:32:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/03/27/mvpa-evidence-for-offline-reply-predicts-revaluation-of-action-values</id>
    <content type="html"><![CDATA[<h4 id="ida-ross-otto-nathaniel-daw-ken-norman">Ida, Ross Otto, Nathaniel Daw, Ken Norman</h4>

<p>phase 1: 
1 – A –&gt; 2
  – B –&gt; 3</p>

<p>phase 2:
1 – A –&gt; 2cents
  – B –&gt; 1 cent</p>

<p>phase 3:
2 – C –&gt; 1 cent
  – D –&gt; 2 cents</p>

<p>3 – E –&gt; 10 cents
  – F –&gt; 25 cents</p>

<p>phase 4: explicitly told, not going to take you to A/B
1 – A –&gt; 2 cents
  – B –&gt; 1 cents</p>

<p>what happens in phase 4?</p>

<p>Have your experiences with phase 2 and phase 3 updated your model-free system?</p>

<p>Revaluation magnitude: how much did your behavior change between phase 2 and phase 4?</p>

<p>In absence of direct experience of changes in state/action/reward trajectories, people integrate isolated experiences to update value and inform their choices. How?</p>

<p>People simulate yet unexperienced trajectories of states, actions, and their outcome. These simulated episodes:
a) integrate isolated experience
b) train &amp; update values to guide future choice</p>

<h3 id="current-study">Current Study</h3>
<p>How can we detect offline replay using MVPA?</p>

<p>Have two different MDPs, one gets revaluated, one doesn’t get revaluated</p>

<p>testing hypothesis: does change in value of MDP “tag” something for being replayed?  If so, expected that neural correlats of revaluated MDP stronger than non-revaluated MDPs.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sleep EEG Meeting: First Pass New Pilot Data]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/03/27/sleep-eeg-meeting-first-pass-new-pilot-data/"/>
    <updated>2014-03-27T11:29:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/03/27/sleep-eeg-meeting-first-pass-new-pilot-data</id>
    <content type="html"><![CDATA[<h2 id="meeting-with-ken">Meeting with Ken:</h2>

<h3 id="status">Status</h3>
<p>Recently received new pilot data from James.  First pass at classification with variety of classification styles didn’t yield phenomenal results (0.25-0.29 using 5 categories)</p>

<h3 id="next-steps">Next Steps</h3>

<h5 id="general-classification">General Classification</h5>
<p>Decided <strong>we should try to isolate exactly when the training data is most classifiable</strong> - there’s no reason that the time point feature in wake data should match up with time point features
in sleep data.  </p>

<p>The general gist of the analysis is this: assuming we have <script type="math/tex">t</script> time points, let’s create a plot with <script type="math/tex"> t </script> data points, where the y-axis plots the <em>cross-validation</em> accuracy using just that particular time point.  We hope that, like Ehren found, there will be a single or range of timepoints that are most predictive between the face categories.  Once we’ve isolated this best time point, we perform the same style of search over the frequencies.  We do this because we don’t necessarily have a notion of how frequencies will carry over into sleep, so instead, we z-score the frequencies across channels to produce a type of topography (manifested in the form of a single z-scored vector across channels) and see which topography is most discriminative.  </p>

<p>So how do we <strong>use</strong> this if the sleep data has the full set of time and frequencies?  We <strong>create a new feature set</strong> by taking the dot product of each (z-scored) channel, frequency topography against the z-scored, channel frequency  topography for the sleep data.  This will produce exactly channel x freq x time features with which we can try to perform cross-validation <strong>on the sleep data</strong></p>

<h5 id="plotting-results--dif-timefreq-bins">Plotting Results + Dif. Time/Freq Bins</h5>
<p>Ken wants me to pick up the following from Ehren: <br />
1. Plot AUC plots - <strong>not optional</strong><br />
2. Look at how Ehren did binning, this reflects a lot of careful consideration on his part  - <strong>as needed</strong>  </p>

<h5 id="logistics">Logistics</h5>
<p>Agreed that I can allocate one day a week to this sleep EEG project</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markov Chain Monte Carlo: A babytown easy introduction Pt. 1: Markov Chains]]></title>
    <link href="http://ElPiloto.github.io/blog/2014/03/23/markov-chain-monte-carlo-a-babytown-easy-introduction/"/>
    <updated>2014-03-23T14:23:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2014/03/23/markov-chain-monte-carlo-a-babytown-easy-introduction</id>
    <content type="html"><![CDATA[<p>You know what’s great? Ice cream, bourbon, and babies riding (safely) on the backs of puppies are some obvious answers.  Here’s a subtler one: <em>Markov chains</em>! </p>

<p>They serve as the basis of many approximate inference techniques and today we’re going to take a preparatory step towards learning about Markov Chain Monte Carlo methods. </p>

<p><ins>Expository note:</ins> sometimes I find it beneficial to motivate and situate terms and objects after introducting them, so if something comes out of the blue, just trust me that it will get explained.  And if it doesn’t get explained, feel free to email me and I will provide you with my address with which you can setup a fiery protest outside of my residence with signs like “We trusted you” and “Betrayal is a four-letter word: luis”</p>

<hr />

<h5 id="markov-chain-definition">Markov Chain Definition</h5>
<p>A Markov chain can be defined via the following:<br /><br />
1. <script type="math/tex">t</script>, a set of <script type="math/tex">N</script> <strong>indices</strong> (you can think of this as time for the …time being)<br />
2. <script type="math/tex">S</script>, a set of <script type="math/tex">K</script> <strong>states</strong>: <script type="math/tex">s_1, s_2 ... s_K</script><br />
3. <script type="math/tex">T</script>, a <strong>transition matrix</strong> specifying the probability of transitioning from state <script type="math/tex">s_i</script> to <script type="math/tex">s_j</script>, for all possible pairs of states.<br />
4. <script type="math/tex">P_0</script>, a <strong>probability distribution</strong> over starting states</p>

<p>Let’s unpack this by using a toy example.  We can define a Markov chain over the sites I visit at any point in time.  For simplicity’s sake, let’s keep it to two sites I use: reddit and facebook.  </p>

<div align="center"><img src="http://ElPiloto.github.io/images/latex/mc.svg" /></div>

<p>In this scenario, <script type="math/tex">S</script>, our state space, contains only two states ( i.e. <script type="math/tex">K = 2</script>): <script type="math/tex">s_1 = reddit</script>, <script type="math/tex">s_2 = facebook</script>, depicted as the vertices in the graph above.  </p>

<p>You’ll also notice that our graph has some directed edges with numbers on them.  This is one way of representing our transition matrix: the number on each edge indicates the transition probability of going from one state to the next.  For instance, the probability of going from reddit to facebook is <script type="math/tex">0.2</script>  Below we explicitly show the transition matrix <script type="math/tex">T</script>, where <script type="math/tex">T_{ij}</script> indicates the probability of transitioning to <script type="math/tex">s_i</script> from <script type="math/tex">s_j</script>:  </p>

<script type="math/tex; mode=display">% &lt;![CDATA[
T = \begin{bmatrix} 0.8 & 0.75\\0.2 & 0.25\end{bmatrix} %]]&gt;</script>

<p>Alright, let’s give ourselves a round of applause: we defined two out of the four components of a Markov chain.  </p>

<p><strong>Now what are these indices I was talking about?</strong>  Indices tell us when we are observing our state. At 8:02 PM, I could either be on reddit or facebook, at 8:03 PM might be on either reddit or facebook, etc.  My example is slightly encumbered by the fact that we usually think of time as continuous, but let’s pretend that we live in a world of discrete time, where I can only change webpages on the change of the minute.  Futhermore, just to make it easy, let’s say we’re going to start at 8:00 PM exactly and continue up until 8:59 PM.  </p>

<p>With these assumptions, we can observe our state (reddit or facebook) exactly 60 times: at time <script type="math/tex">t_1 = 8:00 PM </script> I can be on either reddit or facebook, at time <script type="math/tex">t_2 = 8:01 PM</script>, I can be on either reddit or facebook, etc. all the way up to our last index, time <script type="math/tex">t_{60} = 8:59 PM</script>  </p>

<p>So for this weird, chop-suey-time-into-discrete-chunks-and-the-universe-only-exists-for-60-minutes example, our set of indices would have 60 ordered values ( <script type="math/tex"> N = 60 </script>) because we started this section by saying that our indices tell us when we are observing out state and we only have 60 time points.  </p>

<p>Now let’s bust out the old google translate on this to make it a bit more rigorous.  </p>

<p>Let’s consider some arbitrary time <script type="math/tex">t_{n}</script> a.k.a. our <script type="math/tex">n^{th}</script> index, we observe one of two possible values from our state space (reddit or facebook) with some as yet undefined probability (recall: our transition matrix <script type="math/tex">T</script> defines the probability of transitioning from one state to another, but this is not the same as the probability of being in that state).  If this sounds like a random variable, that’s because it is a random variable.</p>

<p><code>Informal proof: if it looks like a random variable, swims like a random variable,<br />and quacks like a random variable, then it's probably a duck.</code></p>

<p>So, we can use the notation <script type="math/tex">X_{t_n}</script> to denote the random variable over states at index <script type="math/tex">n</script>.  Considering that we have <script type="math/tex">N</script> time points or indices, then we actually have <script type="math/tex">N</script> random variables - each of which operate over the same state space.  Let’s call these random variables <script type="math/tex">X_{t_n}</script> for <script type="math/tex">{t_n} = 1 ... N</script>, remembering that our indices or times are a sequence - that is they are ordered.  </p>

<p>Finally! We have some sense of what these indices are: our Markov chain defines <script type="math/tex">N</script> copies of a random variable <script type="math/tex">X</script> - our index tells us which copy.  </p>

<p>I found this concept of indices to be slightly tricky when looking at other types of random processes.  It’s tempting to think of the index as time and quite appropriate in this context of Markov chains, but I find the much more useful interpretation is that of having a bunch of copies of a random variable and the index telling you to which copy you are referring.  I will continue to use time and index interchangeably to reinforce this.</p>

<p><strong>Status:</strong> we’ve acquired knowledge of three out of the four components of a Markov chain and still have a ways to go to really understand what a Markov chain is.  </p>

<hr />

<p>So let’s backtrack a little bit to the transition matrix now that we’re viewing our Markov chain as a sequence of random variables..  Our transition matrix <script type="math/tex">T</script>, specifically <script type="math/tex">T_{i,j}</script>, tells us the probability of transitioning to some state <script type="math/tex">s_i</script> given that we’re at some state <script type="math/tex">s_j</script>.  That last bit implies that at some time, let’s call it <script type="math/tex">t_n</script>, we’re at <script type="math/tex">s_j</script> and the transition matrix gives us the probability over states for the next time, <script type="math/tex">t_{n+1}</script>:   </p>
<center> $$P(X_{t_{n+1}} = s_i | X_{t_n} = s_j) = T_{i,j}$$ </center>

<p>Well that’s convenient: if I know which state I’m currently in, then all I need to do to predict the next state is look at this transition matrix.  </p>

<p>Let’s consider the inconvenient alternative.  The inconvenient alternative would be a case where to figure out the next state, I have to consider not just the state at time <script type="math/tex">t_n</script>, but the one before that <script type="math/tex">t_{n-1}</script>, and the one before that, and the one before that, all the way to some initial state.  Well that would be a serious pain in the ass.</p>

<p>Let’s get a better feeling for why.  I want to learn the probability of being on reddit at <script type="math/tex">t_3</script>, <script type="math/tex">X_{t_3} = reddit</script>  If we lived in inconvenient land, we would have to consider all possible histories, <script type="math/tex">X_{n-1} ... X_{1}</script>, of length 2:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{align}
P(X_{t_3} = reddit &|\ X_2 = reddit, X_1 = reddit)  \\
P(X_{t_3} = reddit &|\ X_2 = reddit, X_1 = facebook)  \\
P(X_{t_3} = reddit &|\ X_2 = facebook, X_1 = reddit)  \\
P(X_{t_3} = reddit &|\ X_2 = facebook, X_1 = facebook) 
\end{align}
 %]]&gt;</script>

<p>You could see how this blows up if we wanted to look at <script type="math/tex">X_4</script> or <script type="math/tex">X_40</script>.  For <script type="math/tex">X_n</script>, we’d have <script type="math/tex">K^{n-1}</script> possible histories we’d have to consider (recall <script type="math/tex">K</script> is the number of states).  So in our toy case, for <script type="math/tex">n = 3</script> and <script type="math/tex">K = 2</script> possible states, we have <script type="math/tex">2^{2} = 4 </script> possible histories, which is exactly what we see above.   </p>

<p>So I have an idea: let’s <em>not</em> do the inconvenient thing (go America), let’s embrace the Markov property. Markov chains restrict the set of all possible probabilities over sequences to only those which can be explained in terms of “local dynamics”.  Essentially, they say, “the past doesn’t matter, the only thing that affects my future is the present” - it sounds like some new-age, positive-thinking, crispy-hippie mantra like “the past is in the past” (except that Markov chains are actually useful to society :P).   More formally, the <strong>Markov property</strong> says:  </p>
<center>$$ P(X_{t+1} | X_{t}) = P(X_{t+1} | X_t, X_{t-1}, X_{t-2}&#8230; X_{1}) $$ </center>

<p>Now we can get to the last component.  We have our convenient transition matrix (thanks Markov - you da man) which tells us the probability of a next state given our current state, but what about the first state i.e. <script type="math/tex">X_{t_1}</script>?  By definition the first state never comes after another state, thus we can’t use our transition matrix for <script type="math/tex">X_{t_1}</script>.  That’s where <script type="math/tex">P_0</script> comes in - all it does is provide a probability over starting states!  For instance, we can define <script type="math/tex">P_0</script> for our starting state as:  </p>

<center>$$P_0(X_{t_1} = reddit) = 0.5, P_0(X_{t_1} = facebook) $$ </center>

<p><strong>Congratulations:</strong> we’ve just defined the last component of the Markov chain.  Celebrate in your preferred fashion, but please don’t get too rowdy - Markov chain riots are predictably bad.  Personally, I’d like to celebrate with a nice recap.</p>

<p>A Markov chain is a probability distribution over a sequence of outcomes indexed by a discrete set <script type="math/tex">t</script>.  We can think of the outcome for index <script type="math/tex">t_{n}</script> as a random variable: <script type="math/tex">X_{t_n}</script>.  Thus, given <script type="math/tex">N</script> indices, we have <script type="math/tex">N</script> random variables:  <script type="math/tex">X_{t_1}, X_{t_2} ... X_{t_N}</script>.  The Markov assumptiom allows us to represent this distribution over sequence using just the transition matrix <script type="math/tex">T</script>, where <script type="math/tex">T_{i,j}</script> represents the probability of transitioning from state <script type="math/tex">s_j</script> at time <script type="math/tex">t_n</script> to state <script type="math/tex">s_i</script> at time <script type="math/tex">t_{n+1}</script> and a probability distribution over starting states, <script type="math/tex">P_0</script>.</p>

<p>For our toy example, we had N = 60, but <strong>you need to know</strong> that the index set, <script type="math/tex">t</script> could be infinite i.e. <script type="math/tex"> N = \infty </script>  We’ll use this later. As a bonus, it’s worth mentioning we can even have an index set which is continuous, these are called continuous-time Markov chains.</p>

<!--
Now we need some way to actually specify the probability of websites I'll be on over the course of the hour - sounds like a [nightmare](http://www.youtube.com/watch?v=sok_KbPG6iw).  This is where the *Markov property* comes in saying that the probability over next states only depends on my current state: $$ P(X_{t+1} | P(X_{t}) = P(X_{t+1} | P(X_{0}, X_{1}, X_{2} ... X_{t}) $$
-->
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tmux command-completion at bash prompt!]]></title>
    <link href="http://ElPiloto.github.io/blog/2013/05/16/tmux-command-completion-at-bash-prompt/"/>
    <updated>2013-05-16T00:00:00-04:00</updated>
    <id>http://ElPiloto.github.io/blog/2013/05/16/tmux-command-completion-at-bash-prompt</id>
    <content type="html"><![CDATA[<p>After checking out git&#8217;s amazing git command-completion and my <a href="http://sageagainstthemachine.us/blog/2013/04/26/adding-tab-completion-for-your-bash-scripts/">recent discovery</a> of how to implement your own command-completion for bash scripts, I began to wonder why tmux didn&#8217;t have this feature.  After some searching, I found that the tmux installation includes a script file for command-completion in bash!  In the tmux-1.8 distribution, you should find a folder titled &#8220;examples&#8221; which contains a file &#8220;bash_completion_tmux.sh&#8221;.  Just source this file in your .bashrc and you&#8217;re done!!</p>
]]></content>
  </entry>
  
</feed>
